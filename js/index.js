// Generated by CoffeeScript 2.3.0
var assert, noop, path, pug, wch;

assert = require('assert');

noop = require('noop');

path = require('path');

pug = require('pug2lua');

wch = require('wch');

module.exports = function(log) {
  var build, clear, compile, debug, pugCompilers, pugExtsByLang, pugRE, shortPath, watchOptions;
  debug = log.debug('wch-pug');
  shortPath = function(path) {
    return path.replace(process.env.HOME, '~');
  };
  compile = function(input, file) {
    var mtime;
    try {
      mtime = fs.stat(file.dest).mtime.getTime();
    } catch (error) {}
    if (mtime && mtime > file.mtime_ms) {
      return;
    }
    debug('Transpiling:', shortPath(file.path));
    return file.compile(input);
  };
  build = wch.pipeline().read(compile).save(function(file) {
    return file.dest;
  }).each(function(dest, file) {
    return wch.emit('file:build', {
      file: file.path,
      dest
    });
  });
  clear = wch.pipeline().delete(function(file) {
    return file.dest;
  }).each(function(dest, file) {
    return wch.emit('file:delete', {
      file: file.path,
      dest
    });
  });
  pugRE = /\.pug$/;
  pugExtsByLang = {
    lua: '.lua',
    moon: '.lua'
  };
  pugCompilers = {
    lua: function(code) {
      return pug.lua(pug.ast(code));
    },
    moon: async function(code) {
      var ast;
      ast = pug.ast(code);
      await pug.transpile(ast, {
        moon: true
      });
      return pug.lua(ast);
    }
  };
  watchOptions = {
    exts: ['pug', 'html', 'svg']
  };
  return {
    methods: {
      watch: function(dir, opts) {
        var changes, dest, getDest, lang, pugExt;
        assert(opts && typeof opts === 'object');
        assert(typeof opts.dest === 'string');
        lang = opts.lang || 'lua';
        if (!(pugExt = pugExtsByLang[lang])) {
          throw Error('Unknown language: ' + lang);
        }
        dest = path.resolve(this.path, opts.dest);
        getDest = function(file) {
          return path.join(dest, file.name.replace(pugRE, pugExt));
        };
        changes = this.stream(dir, watchOptions);
        return changes.on('data', (file) => {
          var action;
          file.dest = getDest(file);
          if (file.exists) {
            file.compile = pugRE.test(file.name) ? pugCompilers[lang] : noop.arg1;
            action = build;
          } else {
            action = clear;
          }
          return action.call(this, file).catch(function(err) {
            log(log.red('Error while processing:'), file.path);
            return log(log.gray(err.stack));
          });
        });
      }
    }
  };
};
